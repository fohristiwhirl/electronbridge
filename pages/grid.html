<html>
<head><title></title>
<style>
	body {
		margin: 0;
		background-color: black;
		font-family: "Courier";
		overflow: "hidden";
	}
	table {
		border-collapse: collapse;
		table-layout: fixed;
		background: none !important;
	}
	td {
		text-align: center;
		padding: 0;
		cursor: default;
	}
	.hover:hover {
		color: white !important;
	}
	#canvas {
		pointer-events: none;
		background: none !important;
	}
</style>
</head>
<body>

<!-- One has to choose which of the canvas/table are on top... -->

<div id="maintable" style="position: absolute;"></div>
<canvas id="canvas" width="0" height="0" style="position: absolute;"></canvas>

<script>
	"use strict";

	window.onerror = (errorMsg, url, lineNo, columnNo, error) => {
		ipcRenderer.send("error", {msg: `\n    ${url} (${lineNo}):\n    ${errorMsg}`});
	};

	const alert = require("../electronbridge_js/alert");
	const fs = require("fs");
	const ipcRenderer = require("electron").ipcRenderer;

	const canvas = document.getElementById("canvas");
	const virtue = canvas.getContext("2d");

	const animations = require("./animations");

	// --------------------------------------------------------------

	const colour_dict = parse_commented_json("colours.json");

	// --------------------------------------------------------------

	function parse_commented_json(filename) {

		// Comments in the colours.json file can be useful.
		// Remove them for parsing...

		let raw_json_lines = fs.readFileSync(filename).toString().split("\n");

		for (let n = 0; n < raw_json_lines.length; n++) {
			let i = raw_json_lines[n].indexOf("//");
			if (i >= 0) {
				raw_json_lines[n] = raw_json_lines[n].slice(0, i);
			}
		}

		let restored = raw_json_lines.join("\n");

		return JSON.parse(restored);
	}

	function id_from_xy(x, y) {
		return `td_${x}_${y}`;
	}

	function log(m) {
		ipcRenderer.send("log", {msg: m});
	}

	// --------------------------------------------------------------

	function make_renderer() {

		let renderer = {
			pending_flip_opts: null,
			dropped_frames: 0,
			dropped_animations: 0,
			stressed: false,
			inited: false,
			highlight_x: -1,
			highlight_y: -1,
			camerax: 0,
			cameray: 0,
			animators: [],
		};

		renderer.init = (opts) => {

			log("init message received:\n" + JSON.stringify(opts, null, "  "));

			renderer.inited = true;

			renderer.width = opts.width;
			renderer.height = opts.height;
			renderer.boxwidth = opts.boxwidth;
			renderer.boxheight = opts.boxheight;
			renderer.uid = opts.uid;

			log(`initial window size: ${document.querySelector("body").scrollWidth} x ${document.querySelector("body").scrollHeight}`);
			log(`theoretical size required: ${opts.width * opts.boxwidth} x ${opts.height * opts.boxheight}`);

			// Make the table...

			let html = `<table style="font-size: ${opts.fontpercent}%;">`;

			for (let y = 0; y < opts.height; y++) {
				html += "<tr>";
				for (let x = 0; x < opts.width; x++) {
					let id = id_from_xy(x, y);
					html += `<td><div id="${id}" class="hover" style="width: ${opts.boxwidth}; height: ${opts.boxheight}; overflow: hidden;"></div></td>`;
				}
				html += "</tr>";
			}

			html += "</table>";

			document.getElementById("maintable").innerHTML = html;

			// Input handlers...

			document.addEventListener("keydown", (evt) => {
				ipcRenderer.send("keydown", {key: evt.key});
			});

			document.addEventListener("keyup", (evt) => {
				ipcRenderer.send("keyup", {key: evt.key});
			});

			for (let x = 0; x < renderer.width; x++) {
				for (let y = 0; y < renderer.height; y++) {
					let id = id_from_xy(x, y);
					let element = document.getElementById(id);
					element.addEventListener("mousedown", (evt) => {
						evt.preventDefault();								// Prevent selecting text with the mouse
						ipcRenderer.send("mousedown", {x: x, y: y});		// x and y work despite closures because we use "let" in the loops
					});
					element.addEventListener("mouseup", (evt) => {
						ipcRenderer.send("mouseup", {x: x, y: y});			// As above
					});
					element.addEventListener("mouseover", (evt) => {
						ipcRenderer.send("mouseover", {x: x, y: y});		// As above
					});
				}
			}

			requestAnimationFrame(() => renderer.flip());

			// I notice on Chrome on Windows with screen zoom != 100%, there are issues with sizing of elements.
			// e.g. a size 10 element scaled up to 125% will not be 12.5 pixels wide, but maybe 12 or 13.
			// If you have a whole row of such elements, the discrepancy really adds up.
			// Find out how much space we really need and resize the window to that size.

			let body = document.querySelector("body");
			log(`actual body size: ${body.scrollWidth} x ${body.scrollHeight}`);
			renderer.resize(body.scrollWidth, body.scrollHeight);
		};

		renderer.flip = () => {

			// Do this at the start so we don't have to worry about adding this line before every return point

			requestAnimationFrame(() => renderer.flip());

			renderer.cache_true_sizes();

			let opts = renderer.pending_flip_opts;
			renderer.pending_flip_opts = null;

			if (opts) {
				renderer.camerax = opts.camerax;
				renderer.cameray = opts.cameray;
				document.title = opts.title;
			}

			let already_cleared = false;

			for (let n = 0; n < renderer.animators.length; n++) {
				if (renderer.animators[n].finished) {
					renderer.animators.splice(n, 1);
					n--;
				} else {
					if (already_cleared === false) {
						virtue.clearRect(0, 0, canvas.width, canvas.height);
						already_cleared = true;
					}
					renderer.animators[n].step();
				}
			}

			// First return point:

			if (!opts) {
				return;
			}

			// There's some nonsense in JS where astral characters are split in 2.
			// But we can deal with this by using Array.from, which makes an array of strings each representing a character.

			let char_array = Array.from(opts.chars);
			let colour_array = Array.from(opts.colours);
			let highlight = opts.highlight;

			// Highlight... (grey square)

			if (highlight.x !== renderer.highlight_x || highlight.y !== renderer.highlight_y) {

				// Clear old highlight...

				if (renderer.highlight_x >= 0) {
					let id = id_from_xy(renderer.highlight_x, renderer.highlight_y);
					let element = document.getElementById(id);
					if (element) {
						element.style["transition"] = "none";
						element.style["background-color"] = "#000000";
					}
				}

				// Set new highlight...

				renderer.highlight_x = highlight.x;
				renderer.highlight_y = highlight.y;

				if (renderer.highlight_x >= 0) {
					let id = id_from_xy(renderer.highlight_x, renderer.highlight_y);
					let element = document.getElementById(id);
					if (element) {
						element.style["transition"] = "none";
						element.style["background-color"] = "#494949";
					}
				}
			}

			// Character, colour...

			for (let x = 0; x < renderer.width; x++) {
				for (let y = 0; y < renderer.height; y++) {
					let index = y * renderer.width + x;
					let id = id_from_xy(x, y);
					let element = document.getElementById(id);
					if (element) {

						// Set character...

						element.innerHTML = char_array[index];

						// Set colour...

						let colour_key = colour_array[index];
						let colour = colour_dict[colour_key];

						if (colour) {
							element.style["color"] = colour;
						} else {
							element.style["color"] = "#ffffff";
						}
					}
				}
			}

			return;
		};

		renderer.resize = (xpixels, ypixels) => {
			let msg = {
				xpixels: xpixels,
				ypixels: ypixels,
			};
			ipcRenderer.send("request_resize", msg);
			canvas.width = xpixels;
			canvas.height = ypixels;
		};

		renderer.cache_true_sizes = () => {
			let top_left_element = document.getElementById(id_from_xy(0, 0));
			let top_left_bound = top_left_element.getBoundingClientRect();
			let top_left_x = top_left_bound.left;
			let top_left_y = top_left_bound.top;

			let bottom_right_element = document.getElementById(id_from_xy(renderer.width - 1, renderer.height - 1));
			let bottom_right_bound = bottom_right_element.getBoundingClientRect();
			let bottom_right_x = bottom_right_bound.right;
			let bottom_right_y = bottom_right_bound.bottom;

			renderer.true_boxwidth = (bottom_right_x - top_left_x) / renderer.width;
			renderer.true_boxheight = (bottom_right_y - top_left_y) / renderer.height;
		};

		renderer.pixel_xy_from_grid = (x, y) => {

			// Takes the camera position into account. Returns the centre of the box.

			let i = (x - renderer.camerax) * renderer.true_boxwidth + renderer.true_boxwidth / 2;
			let j = (y - renderer.cameray) * renderer.true_boxheight + renderer.true_boxheight / 2;

			return [i, j];
		};

		renderer.log = log;

		return renderer;
	}

	// --------------------------------------------------------------

	let renderer = make_renderer();

	// --------------------------------------------------------------

	ipcRenderer.on("init", (event, opts) => {
		renderer.init(opts);
	});

	ipcRenderer.on("update", (event, opts) => {
		if (!renderer.inited) {
			return;
		}
		if (renderer.pending_flip_opts !== null) {
			renderer.dropped_frames += 1;
			renderer.stressed = true;		// Not sure if this is adequate.
		} else {
			renderer.stressed = false;
		}
		renderer.pending_flip_opts = opts;
	});

	ipcRenderer.on("effect", (event, opts) => {
		if (!renderer.inited) {
			return;
		}
		if (renderer.stressed) {
			renderer.dropped_animations += 1;
			return;
		}
		let factory = animations[opts.function];
		renderer.animators.push(factory(opts, renderer));
	});

	// --------------------------------------------------------------

	ipcRenderer.send("ready", null);	// triggers an init message to be sent to us

</script>
</body>
</html>
