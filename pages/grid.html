<html>
<head><title></title>
<style>
	body {
		margin: 0;
		background-color: black;
		font-family: "Courier";
	}
	table {
		border-collapse: collapse;
		table-layout: fixed;
	}
	td {
		text-align: center;
		color: white;
		padding: 0;
		cursor: default;
	}
	td:hover {
		color: white !important;
	}
	.overlay {
		pointer-events: none;
		background: none !important;
	}
</style>
</head>
<body>

<div id="maintable" style="position: absolute;"></div>

<script>
	"use strict";

	const alert = require("../electronbridge_js/alert");
	const fs = require("fs");
	const ipcRenderer = require("electron").ipcRenderer;

	// --------------------------------------------------------------

	const colour_dict = JSON.parse(fs.readFileSync("colours.json"));

	// --------------------------------------------------------------

	function id_from_xy(x, y) {
		return `td_${x}_${y}`;
	}

	// --------------------------------------------------------------

	function make_renderer() {

		let renderer = {
			pending_flip_opts: null,
			dropped_frames: 0,
			inited: false,
			highlight_x: -1,
			highlight_y: -1,
			pending_flash_fades: [],
		};

		renderer.init = (opts) => {

			renderer.inited = true;

			renderer.width = opts.width;
			renderer.height = opts.height;
			renderer.boxwidth = opts.boxwidth;
			renderer.boxheight = opts.boxheight;
			renderer.uid = opts.uid;

			// Make the table...

			let html = `<table style="font-size: ${opts.fontpercent}%;">`;

			for (let y = 0; y < opts.height; y++) {
				html += "<tr>";
				for (let x = 0; x < opts.width; x++) {
					let id = id_from_xy(x, y);
					html += `<td><div id="${id}" style="width: ${opts.boxwidth}; height: ${opts.boxheight}; overflow: hidden;"></div></td>`;
				}
				html += "</tr>";
			}

			html += "</table>";

			document.getElementById("maintable").innerHTML = html;

			// Although the window is probably already the correct size, do this anyway...

			renderer.resize(opts.width * opts.boxwidth, opts.height * opts.boxheight);

			// Input handlers...

			document.addEventListener("keydown", (evt) => {
				ipcRenderer.send("keydown", {key: evt.key});
			});

			document.addEventListener("keyup", (evt) => {
				ipcRenderer.send("keyup", {key: evt.key});
			});

			for (let x = 0; x < renderer.width; x++) {
				for (let y = 0; y < renderer.height; y++) {
					let id = id_from_xy(x, y);
					let element = document.getElementById(id);
					element.addEventListener("mousedown", (evt) => {
						evt.preventDefault();								// Prevent selecting text with the mouse
						ipcRenderer.send("mousedown", {x: x, y: y});		// x and y work despite closures because we use "let" in the loops
					});
					element.addEventListener("mouseup", (evt) => {
						ipcRenderer.send("mouseup", {x: x, y: y});			// Works despite closures because we use "let" in the loops
					});
				}
			}

			requestAnimationFrame(() => renderer.flip());
		};

		renderer.flip = () => {

			// Do this at the start so we don't have to worry about adding this line before every return point

			requestAnimationFrame(() => renderer.flip());

			for (let n = 0; n < renderer.pending_flash_fades.length; n++) {
				renderer.pending_flash_fades[n]();
			}
			renderer.pending_flash_fades = [];

			let opts = renderer.pending_flip_opts;
			if (!opts) {
				return;
			}
			renderer.pending_flip_opts = null;

			// There's some nonsense in JS where astral characters are split in 2.
			// But we can deal with this by using Array.from, which makes an array of strings each representing a character.

			let char_array = Array.from(opts.chars);
			let colour_array = Array.from(opts.colours);
			let flash_array = Array.from(opts.flashes);
			let highlight = opts.highlight;

			// Highlight... (grey square)

			if (highlight.x !== renderer.highlight_x || highlight.y !== renderer.highlight_y) {

				// Clear old highlight...

				if (renderer.highlight_x >= 0) {
					let id = id_from_xy(renderer.highlight_x, renderer.highlight_y);
					let element = document.getElementById(id);
					if (element) {
						element.style["transition"] = "none";
						element.style["background-color"] = "#000000";
					}
				}

				// Set new highlight...

				renderer.highlight_x = highlight.x;
				renderer.highlight_y = highlight.y;

				if (renderer.highlight_x >= 0) {
					let id = id_from_xy(renderer.highlight_x, renderer.highlight_y);
					let element = document.getElementById(id);
					if (element) {
						element.style["transition"] = "none";
						element.style["background-color"] = "#494949";
					}
				}
			}

			// Character, colour, and flashes...

			for (let x = 0; x < renderer.width; x++) {
				for (let y = 0; y < renderer.height; y++) {
					let index = y * renderer.width + x;
					let id = id_from_xy(x, y);
					let element = document.getElementById(id);
					if (element) {

						// Set character...

						element.innerHTML = char_array[index];

						// Set colour...

						let colour_key = colour_array[index];
						let colour = colour_dict[colour_key];

						if (colour) {
							element.style["color"] = colour;
						} else {
							element.style["color"] = "#ffffff";
						}

						// Handle flashes...

						let flash_key = flash_array[index];

						if (flash_key !== " ") {
							let flash_colour = colour_dict[flash_key];
							if (flash_colour) {
								element.style["transition"] = "none";
								element.style["background-color"] = flash_colour;

								// I don't think we can start the fade immediately (we
								// need to wait for a paint I think, otherwise Chrome
								// doesn't know anything happened?)

								renderer.pending_flash_fades.push(() => {
									element.style["transition"] = "background-color .50s ease-in-out";
									element.style["background-color"] = renderer.highlight_x == x && renderer.highlight_y == y ? "#494949" : "#000000";
								});
							}
						}
					}
				}
			}
		};

		renderer.resize = (xpixels, ypixels) => {
			let msg = {
				xpixels: xpixels,
				ypixels: ypixels,
			};
			ipcRenderer.send("request_resize", msg);
		};

		return renderer;
	}

	// --------------------------------------------------------------

	let renderer = make_renderer();

	// --------------------------------------------------------------

	ipcRenderer.on("init", (event, opts) => {
		renderer.init(opts);
	});

	ipcRenderer.on("update", (event, opts) => {
		if (!renderer.inited) {
			return;
		}
		if (renderer.pending_flip_opts != null) {
			renderer.dropped_frames += 1;
		}
		renderer.pending_flip_opts = opts;
	});

	// --------------------------------------------------------------

	ipcRenderer.send("ready", null);	// triggers an init message to be sent to us

</script>
</body>
</html>
